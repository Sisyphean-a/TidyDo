# 分类排序

<cite>
**Referenced Files in This Document**   
- [useDragSort.js](file://src/composables/useDragSort.js)
- [TodoSidebar.vue](file://src/components/TodoSidebar.vue)
- [useCategoriesStore.js](file://src/stores/useCategoriesStore.js)
- [todoService.js](file://src/services/todoService.js)
</cite>

## 目录
1. [引言](#引言)
2. [核心组件分析](#核心组件分析)
3. [拖拽排序工作原理](#拖拽排序工作原理)
4. [状态管理与事件机制](#状态管理与事件机制)
5. [数据持久化流程](#数据持久化流程)
6. [用户体验优化](#用户体验优化)
7. [移动端适配与性能调优](#移动端适配与性能调优)
8. [结论](#结论)

## 引言

本文档深入讲解基于长按拖拽的分类排序功能实现。详细分析`useDragSort`组合函数的工作原理，包括长按检测、拖拽状态管理、全局事件监听机制以及`_updateDropLine`的动态计算逻辑。说明`TodoSidebar`组件如何集成`useDragSort`，通过`startLongPress`和`endDrag`实现触摸与鼠标双模式支持。解释`reorderCategoriesByDrag`方法在store中的作用及与服务层的协作流程。提供拖拽冲突（如滚动条冲突、多指操作）的解决方案，阐述防抖策略和用户体验优化措施（如拖拽反馈动画、排序完成提示）。包含移动端适配注意事项和性能调优建议。

## 核心组件分析

### useDragSort 组合函数

`useDragSort`是实现分类拖拽排序的核心组合式函数，提供了完整的拖拽逻辑和状态管理。该函数通过Vue的响应式系统管理拖拽状态，并封装了从长按检测到排序完成的完整生命周期。

```mermaid
classDiagram
class useDragSort {
+dragState : Ref<Object>
+DRAG_CONFIG : Object
+startLongPress(category, event)
+cancelLongPress()
+handleDragMove(event)
+endDrag()
+cleanup()
}
class dragState {
+isDragging : boolean
+draggedCategoryId : string
+dropLinePosition : Object
+targetIndex : number
+longPressTimer : Timer
+startPosition : Object
}
useDragSort --> dragState : "包含"
```

**Diagram sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L27-L236)

**Section sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L1-L237)

### TodoSidebar 组件

`TodoSidebar`组件是分类列表的UI容器，负责渲染分类项并集成拖拽功能。该组件通过`VueDraggable`组件实现可视化拖拽效果，并与`useDragSort`组合函数协同工作。

```mermaid
classDiagram
class TodoSidebar {
+categories : ComputedRef<Array>
+isDragging : Ref<boolean>
+onDragStart()
+onDragEnd(event)
+handleCategoryClick(category)
+handleEditCategory(category)
}
class CategoryItem {
+category : Object
+index : number
+category-wrapper : CSS Class
+category-item : CSS Class
+category-actions : CSS Class
}
TodoSidebar --> CategoryItem : "包含多个"
TodoSidebar --> useCategoriesStore : "使用"
```

**Diagram sources**
- [TodoSidebar.vue](file://src/components/TodoSidebar.vue#L1-L577)

**Section sources**
- [TodoSidebar.vue](file://src/components/TodoSidebar.vue#L1-L577)

## 拖拽排序工作原理

### 长按检测机制

长按检测是触发拖拽模式的关键机制。系统通过`startLongPress`方法实现长按检测，当用户在分类项上持续按压达到预设时间（500毫秒）后，才激活拖拽模式。

```mermaid
sequenceDiagram
participant User as "用户"
participant TodoSidebar as "TodoSidebar组件"
participant useDragSort as "useDragSort"
User->>TodoSidebar : 触摸/点击分类项
TodoSidebar->>useDragSort : 调用startLongPress
useDragSort->>useDragSort : 设置长按计时器(500ms)
alt 500ms内释放
User->>useDragSort : 取消触摸/点击
useDragSort->>useDragSort : 清除计时器
else 500ms内未释放
useDragSort->>useDragSort : 触发_startDrag
useDragSort->>useDragSort : 进入拖拽模式
useDragSort->>TodoSidebar : 显示"拖拽模式已启动"提示
end
```

**Diagram sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L91-L108)

**Section sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L91-L108)

### 拖拽状态管理

拖拽状态由`dragState`响应式对象统一管理，包含拖拽状态、被拖拽的分类ID、拖拽线位置、目标索引等关键信息。

```mermaid
stateDiagram-v2
[*] --> Idle
Idle --> LongPressDetected : "startLongPress"
LongPressDetected --> Dragging : "长按计时器超时"
Dragging --> DropPositionCalculated : "handleDragMove"
DropPositionCalculated --> SortingCompleted : "endDrag"
SortingCompleted --> Idle : "重置状态"
note right of LongPressDetected
检测到长按操作
设置500ms计时器
end note
note right of Dragging
激活拖拽模式
添加全局事件监听
显示拖拽提示
end note
note right of DropPositionCalculated
实时计算插入位置
更新拖拽线位置
显示视觉反馈
end note
```

**Diagram sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L45-L55)

**Section sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L45-L55)

## 状态管理与事件机制

### 全局事件监听机制

为确保拖拽操作的流畅性，系统在进入拖拽模式时添加全局事件监听器，即使鼠标/手指移出分类项范围也能持续跟踪位置。

```mermaid
flowchart TD
A[开始拖拽] --> B[添加全局事件监听]
B --> C["document.addEventListener('mousemove', handleDragMove)"]
B --> D["document.addEventListener('mouseup', endDrag)"]
B --> E["document.addEventListener('touchmove', handleDragMove)"]
B --> F["document.addEventListener('touchend', endDrag)"]
C --> G[实时更新拖拽线位置]
D --> H[结束拖拽并执行排序]
E --> G
F --> H
H --> I[移除全局事件监听]
I --> J[重置拖拽状态]
```

**Diagram sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L184-L195)

**Section sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L184-L195)

### _updateDropLine 动态计算逻辑

`_updateDropLine`方法负责实时计算拖拽线的显示位置，通过遍历所有分类元素并比较鼠标/触摸点的Y坐标来确定插入位置。

```mermaid
flowchart TD
Start([开始计算]) --> GetElements["获取所有.category-wrapper元素"]
GetElements --> Loop["遍历每个分类元素"]
Loop --> GetRect["获取元素边界矩形"]
GetRect --> CalculateCenter["计算元素中心Y坐标"]
CalculateCenter --> Compare["比较clientY与中心Y坐标"]
Compare --> |clientY ≤ centerY| InsertBefore["插入到当前元素之前"]
Compare --> |clientY > centerY 且为最后一个| InsertAfter["插入到最后一个之后"]
InsertBefore --> SetTargetIndex["设置targetIndex = i"]
InsertAfter --> SetTargetIndex["设置targetIndex = i+1"]
SetTargetIndex --> UpdateState["更新dragState状态"]
UpdateState --> End([结束计算])
```

**Diagram sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L164-L182)

**Section sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L164-L182)

## 数据持久化流程

### reorderCategoriesByDrag 方法作用

`reorderCategoriesByDrag`方法位于`useCategoriesStore`中，作为store层的公共接口，协调拖拽排序的业务逻辑。

```mermaid
sequenceDiagram
participant TodoSidebar as "TodoSidebar"
participant useCategoriesStore as "useCategoriesStore"
participant CategoryService as "CategoryService"
TodoSidebar->>useCategoriesStore : 调用reorderCategoriesByDrag
useCategoriesStore->>CategoryService : 调用reorderByDrag
CategoryService->>CategoryService : 执行排序逻辑
CategoryService-->>useCategoriesStore : 返回排序结果
useCategoriesStore->>useCategoriesStore : 重新加载分类数据
useCategoriesStore-->>TodoSidebar : 返回操作结果
TodoSidebar->>TodoSidebar : 更新UI并显示提示
```

**Diagram sources**
- [useCategoriesStore.js](file://src/stores/useCategoriesStore.js#L146-L155)

**Section sources**
- [useCategoriesStore.js](file://src/stores/useCategoriesStore.js#L146-L155)

### 服务层协作流程

服务层的`reorderByDrag`方法负责实际的数据操作和持久化存储，确保排序结果被正确保存到IndexedDB中。

```mermaid
flowchart TD
A[reorderByDrag] --> B[获取当前分类列表]
B --> C[查找当前索引]
C --> D[验证参数有效性]
D --> |无效| E[返回false]
D --> |有效| F[移除当前项]
F --> G[计算调整后的目标索引]
G --> H[插入到目标位置]
H --> I[更新所有分类的order字段]
I --> J[保存到IndexedDB]
J --> K[返回操作结果]
```

**Diagram sources**
- [todoService.js](file://src/services/todoService.js#L196-L225)

**Section sources**
- [todoService.js](file://src/services/todoService.js#L196-L225)

## 用户体验优化

### 拖拽冲突解决方案

系统通过多种策略解决常见的拖拽冲突问题：

```mermaid
flowchart TD
A[拖拽冲突问题] --> B[滚动条冲突]
A --> C[多指操作冲突]
A --> D[误触点击冲突]
B --> B1["阻止默认行为preventDefault()"]
B --> B2["使用passive: false选项"]
B --> B3["限制垂直方向移动"]
C --> C1["只处理第一个触摸点"]
C --> C2["忽略多指操作"]
C --> C3["添加触摸点数量检测"]
D --> D1["长按500ms才激活拖拽"]
D --> D2["区分点击和拖拽"]
D --> D3["取消计时器处理快速点击"]
```

**Section sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L91-L118)

### 防抖策略与反馈机制

系统实现了多层次的用户体验优化措施：

```mermaid
flowchart LR
A[防抖策略] --> A1["长按500ms激活"]
A --> A2["避免误操作"]
A --> A3["提升操作精度"]
B[视觉反馈] --> B1["拖拽项半透明"]
B --> B2["添加阴影效果"]
B --> B3["显示拖拽线"]
B --> B4["高亮目标位置"]
C[消息提示] --> C1["拖拽模式启动提示"]
C --> C2["排序成功提示"]
C --> C3["排序失败提示"]
C --> C4["自动消失机制"]
D[动画效果] --> D1["平滑过渡"]
D --> D2["缩放效果"]
D --> D3["旋转微调"]
D --> D4["z-index提升"]
```

**Section sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L110-L115)
- [TodoSidebar.vue](file://src/components/TodoSidebar.vue#L120-L135)

## 移动端适配与性能调优

### 移动端适配注意事项

针对移动端设备的特殊性，系统进行了专门的适配优化：

```mermaid
flowchart TD
A[移动端适配] --> B[触摸事件支持]
A --> C[响应式布局]
A --> D[手势识别]
A --> E[性能优化]
B --> B1["支持touchstart/touchmove"]
B --> B2["支持touchend"]
B --> B3["获取touches[0]坐标"]
C --> C1["侧边栏收起模式"]
C --> C2["紧凑布局"]
C --> C3["图标优先显示"]
D --> D1["长按检测"]
D --> D2["防止滚动冲突"]
D --> D3["单指操作限制"]
E --> E1["减少重绘"]
E --> E2["优化事件监听"]
E --> E3["内存泄漏防护"]
```

**Section sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L100-L102)
- [TodoSidebar.vue](file://src/components/TodoSidebar.vue#L1-L577)

### 性能调优建议

为确保拖拽排序功能的高性能运行，建议采取以下优化措施：

```mermaid
flowchart LR
A[性能调优] --> B[事件监听优化]
A --> C[DOM操作优化]
A --> D[内存管理]
A --> E[错误处理]
B --> B1["使用被动事件监听器"]
B --> B2["及时移除事件监听"]
B --> B3["避免事件冒泡"]
C --> C1["批量DOM更新"]
C --> C2["减少重排重绘"]
C --> C3["使用CSS变换"]
D --> D1["组件卸载清理"]
D --> D2["定时器清理"]
D --> D3["引用释放"]
E --> E1["错误边界处理"]
E --> E2["优雅降级"]
E --> E3["用户反馈机制"]
```

**Section sources**
- [useDragSort.js](file://src/composables/useDragSort.js#L196-L210)
- [useDragSort.js](file://src/composables/useDragSort.js#L225-L236)

## 结论

本文档全面分析了基于长按拖拽的分类排序功能实现。`useDragSort`组合函数通过精确的长按检测、完善的拖拽状态管理和智能的拖拽线位置计算，实现了流畅的拖拽体验。`TodoSidebar`组件与`useDragSort`紧密集成，支持触摸和鼠标双模式操作。数据层通过`useCategoriesStore`和`CategoryService`的协作，确保排序结果的持久化存储。系统通过长按激活、全局事件监听、视觉反馈和消息提示等机制，有效解决了拖拽冲突问题并提升了用户体验。移动端适配和性能调优措施保证了功能在各种设备上的稳定运行。整体设计体现了分层架构、关注点分离和用户体验优先的原则，为类似功能的开发提供了有价值的参考。